// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: card_transactions.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const countCardTransactions = `-- name: CountCardTransactions :one
SELECT COUNT(*) FROM card_transactions
WHERE card_id = $1
`

func (q *Queries) CountCardTransactions(ctx context.Context, cardID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, countCardTransactions, cardID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCardTransaction = `-- name: CreateCardTransaction :one
INSERT INTO card_transactions (
    card_id,
    user_id,
    amount_cents,
    merchant_name,
    merchant_category,
    status,
    is_international,
    transaction_date
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, card_id, user_id, amount_cents, merchant_name, merchant_category, status, is_international, transaction_date, created_at
`

type CreateCardTransactionParams struct {
	CardID           uuid.UUID      `json:"card_id"`
	UserID           uuid.UUID      `json:"user_id"`
	AmountCents      int64          `json:"amount_cents"`
	MerchantName     string         `json:"merchant_name"`
	MerchantCategory sql.NullString `json:"merchant_category"`
	Status           string         `json:"status"`
	IsInternational  sql.NullBool   `json:"is_international"`
	TransactionDate  time.Time      `json:"transaction_date"`
}

func (q *Queries) CreateCardTransaction(ctx context.Context, arg CreateCardTransactionParams) (CardTransaction, error) {
	row := q.db.QueryRowContext(ctx, createCardTransaction,
		arg.CardID,
		arg.UserID,
		arg.AmountCents,
		arg.MerchantName,
		arg.MerchantCategory,
		arg.Status,
		arg.IsInternational,
		arg.TransactionDate,
	)
	var i CardTransaction
	err := row.Scan(
		&i.ID,
		&i.CardID,
		&i.UserID,
		&i.AmountCents,
		&i.MerchantName,
		&i.MerchantCategory,
		&i.Status,
		&i.IsInternational,
		&i.TransactionDate,
		&i.CreatedAt,
	)
	return i, err
}

const getCardTransactionByID = `-- name: GetCardTransactionByID :one
SELECT id, card_id, user_id, amount_cents, merchant_name, merchant_category, status, is_international, transaction_date, created_at FROM card_transactions
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetCardTransactionByID(ctx context.Context, id uuid.UUID) (CardTransaction, error) {
	row := q.db.QueryRowContext(ctx, getCardTransactionByID, id)
	var i CardTransaction
	err := row.Scan(
		&i.ID,
		&i.CardID,
		&i.UserID,
		&i.AmountCents,
		&i.MerchantName,
		&i.MerchantCategory,
		&i.Status,
		&i.IsInternational,
		&i.TransactionDate,
		&i.CreatedAt,
	)
	return i, err
}

const getCardTransactionsByCategory = `-- name: GetCardTransactionsByCategory :many
SELECT
    merchant_category,
    COUNT(*) as transaction_count,
    SUM(amount_cents) as total_amount_cents
FROM card_transactions
WHERE user_id = $1
  AND transaction_date >= $2
  AND transaction_date <= $3
GROUP BY merchant_category
ORDER BY total_amount_cents DESC
`

type GetCardTransactionsByCategoryParams struct {
	UserID    uuid.UUID `json:"user_id"`
	StartDate time.Time `json:"start_date"`
	EndDate   time.Time `json:"end_date"`
}

type GetCardTransactionsByCategoryRow struct {
	MerchantCategory sql.NullString `json:"merchant_category"`
	TransactionCount int64          `json:"transaction_count"`
	TotalAmountCents int64          `json:"total_amount_cents"`
}

func (q *Queries) GetCardTransactionsByCategory(ctx context.Context, arg GetCardTransactionsByCategoryParams) ([]GetCardTransactionsByCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getCardTransactionsByCategory, arg.UserID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCardTransactionsByCategoryRow{}
	for rows.Next() {
		var i GetCardTransactionsByCategoryRow
		if err := rows.Scan(&i.MerchantCategory, &i.TransactionCount, &i.TotalAmountCents); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCardTransactionsByDateRange = `-- name: GetCardTransactionsByDateRange :many
SELECT id, card_id, user_id, amount_cents, merchant_name, merchant_category, status, is_international, transaction_date, created_at FROM card_transactions
WHERE user_id = $1
  AND transaction_date >= $2
  AND transaction_date <= $3
ORDER BY transaction_date DESC
`

type GetCardTransactionsByDateRangeParams struct {
	UserID    uuid.UUID `json:"user_id"`
	StartDate time.Time `json:"start_date"`
	EndDate   time.Time `json:"end_date"`
}

func (q *Queries) GetCardTransactionsByDateRange(ctx context.Context, arg GetCardTransactionsByDateRangeParams) ([]CardTransaction, error) {
	rows, err := q.db.QueryContext(ctx, getCardTransactionsByDateRange, arg.UserID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CardTransaction{}
	for rows.Next() {
		var i CardTransaction
		if err := rows.Scan(
			&i.ID,
			&i.CardID,
			&i.UserID,
			&i.AmountCents,
			&i.MerchantName,
			&i.MerchantCategory,
			&i.Status,
			&i.IsInternational,
			&i.TransactionDate,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCardTransactions = `-- name: ListCardTransactions :many
SELECT id, card_id, user_id, amount_cents, merchant_name, merchant_category, status, is_international, transaction_date, created_at FROM card_transactions
WHERE card_id = $1
ORDER BY transaction_date DESC
LIMIT $2 OFFSET $3
`

type ListCardTransactionsParams struct {
	CardID uuid.UUID `json:"card_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

func (q *Queries) ListCardTransactions(ctx context.Context, arg ListCardTransactionsParams) ([]CardTransaction, error) {
	rows, err := q.db.QueryContext(ctx, listCardTransactions, arg.CardID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CardTransaction{}
	for rows.Next() {
		var i CardTransaction
		if err := rows.Scan(
			&i.ID,
			&i.CardID,
			&i.UserID,
			&i.AmountCents,
			&i.MerchantName,
			&i.MerchantCategory,
			&i.Status,
			&i.IsInternational,
			&i.TransactionDate,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserCardTransactions = `-- name: ListUserCardTransactions :many
SELECT id, card_id, user_id, amount_cents, merchant_name, merchant_category, status, is_international, transaction_date, created_at FROM card_transactions
WHERE user_id = $1
ORDER BY transaction_date DESC
LIMIT $2 OFFSET $3
`

type ListUserCardTransactionsParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

func (q *Queries) ListUserCardTransactions(ctx context.Context, arg ListUserCardTransactionsParams) ([]CardTransaction, error) {
	rows, err := q.db.QueryContext(ctx, listUserCardTransactions, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CardTransaction{}
	for rows.Next() {
		var i CardTransaction
		if err := rows.Scan(
			&i.ID,
			&i.CardID,
			&i.UserID,
			&i.AmountCents,
			&i.MerchantName,
			&i.MerchantCategory,
			&i.Status,
			&i.IsInternational,
			&i.TransactionDate,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
