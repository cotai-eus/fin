// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: budgets.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const countUserBudgets = `-- name: CountUserBudgets :one
SELECT COUNT(*) FROM budgets
WHERE user_id = $1
`

func (q *Queries) CountUserBudgets(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUserBudgets, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBudget = `-- name: CreateBudget :one
INSERT INTO budgets (
    user_id,
    category,
    period,
    limit_cents,
    current_spent_cents,
    alert_threshold,
    alerts_enabled,
    start_date,
    end_date
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, user_id, category, period, limit_cents, current_spent_cents, alert_threshold, alerts_enabled, start_date, end_date, created_at
`

type CreateBudgetParams struct {
	UserID            uuid.UUID     `json:"user_id"`
	Category          string        `json:"category"`
	Period            string        `json:"period"`
	LimitCents        int64         `json:"limit_cents"`
	CurrentSpentCents sql.NullInt64 `json:"current_spent_cents"`
	AlertThreshold    sql.NullInt16 `json:"alert_threshold"`
	AlertsEnabled     sql.NullBool  `json:"alerts_enabled"`
	StartDate         time.Time     `json:"start_date"`
	EndDate           time.Time     `json:"end_date"`
}

func (q *Queries) CreateBudget(ctx context.Context, arg CreateBudgetParams) (Budget, error) {
	row := q.db.QueryRowContext(ctx, createBudget,
		arg.UserID,
		arg.Category,
		arg.Period,
		arg.LimitCents,
		arg.CurrentSpentCents,
		arg.AlertThreshold,
		arg.AlertsEnabled,
		arg.StartDate,
		arg.EndDate,
	)
	var i Budget
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Category,
		&i.Period,
		&i.LimitCents,
		&i.CurrentSpentCents,
		&i.AlertThreshold,
		&i.AlertsEnabled,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
	)
	return i, err
}

const deleteBudget = `-- name: DeleteBudget :exec
DELETE FROM budgets
WHERE id = $1
`

func (q *Queries) DeleteBudget(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteBudget, id)
	return err
}

const getBudgetByCategoryAndPeriod = `-- name: GetBudgetByCategoryAndPeriod :one
SELECT id, user_id, category, period, limit_cents, current_spent_cents, alert_threshold, alerts_enabled, start_date, end_date, created_at FROM budgets
WHERE user_id = $1
  AND category = $2
  AND period = $3
LIMIT 1
`

type GetBudgetByCategoryAndPeriodParams struct {
	UserID   uuid.UUID `json:"user_id"`
	Category string    `json:"category"`
	Period   string    `json:"period"`
}

func (q *Queries) GetBudgetByCategoryAndPeriod(ctx context.Context, arg GetBudgetByCategoryAndPeriodParams) (Budget, error) {
	row := q.db.QueryRowContext(ctx, getBudgetByCategoryAndPeriod, arg.UserID, arg.Category, arg.Period)
	var i Budget
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Category,
		&i.Period,
		&i.LimitCents,
		&i.CurrentSpentCents,
		&i.AlertThreshold,
		&i.AlertsEnabled,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
	)
	return i, err
}

const getBudgetByID = `-- name: GetBudgetByID :one
SELECT id, user_id, category, period, limit_cents, current_spent_cents, alert_threshold, alerts_enabled, start_date, end_date, created_at FROM budgets
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetBudgetByID(ctx context.Context, id uuid.UUID) (Budget, error) {
	row := q.db.QueryRowContext(ctx, getBudgetByID, id)
	var i Budget
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Category,
		&i.Period,
		&i.LimitCents,
		&i.CurrentSpentCents,
		&i.AlertThreshold,
		&i.AlertsEnabled,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
	)
	return i, err
}

const getBudgetForUpdate = `-- name: GetBudgetForUpdate :one
SELECT id, user_id, category, period, limit_cents, current_spent_cents, alert_threshold, alerts_enabled, start_date, end_date, created_at FROM budgets
WHERE id = $1
FOR UPDATE
`

func (q *Queries) GetBudgetForUpdate(ctx context.Context, id uuid.UUID) (Budget, error) {
	row := q.db.QueryRowContext(ctx, getBudgetForUpdate, id)
	var i Budget
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Category,
		&i.Period,
		&i.LimitCents,
		&i.CurrentSpentCents,
		&i.AlertThreshold,
		&i.AlertsEnabled,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
	)
	return i, err
}

const getBudgetsNearLimit = `-- name: GetBudgetsNearLimit :many
SELECT id, user_id, category, period, limit_cents, current_spent_cents, alert_threshold, alerts_enabled, start_date, end_date, created_at FROM budgets
WHERE user_id = $1
  AND alerts_enabled = true
  AND (current_spent_cents::float / limit_cents::float * 100) >= alert_threshold
ORDER BY created_at DESC
`

func (q *Queries) GetBudgetsNearLimit(ctx context.Context, userID uuid.UUID) ([]Budget, error) {
	rows, err := q.db.QueryContext(ctx, getBudgetsNearLimit, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Budget{}
	for rows.Next() {
		var i Budget
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Category,
			&i.Period,
			&i.LimitCents,
			&i.CurrentSpentCents,
			&i.AlertThreshold,
			&i.AlertsEnabled,
			&i.StartDate,
			&i.EndDate,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOverBudgets = `-- name: GetOverBudgets :many
SELECT id, user_id, category, period, limit_cents, current_spent_cents, alert_threshold, alerts_enabled, start_date, end_date, created_at FROM budgets
WHERE user_id = $1
  AND current_spent_cents > limit_cents
ORDER BY created_at DESC
`

func (q *Queries) GetOverBudgets(ctx context.Context, userID uuid.UUID) ([]Budget, error) {
	rows, err := q.db.QueryContext(ctx, getOverBudgets, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Budget{}
	for rows.Next() {
		var i Budget
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Category,
			&i.Period,
			&i.LimitCents,
			&i.CurrentSpentCents,
			&i.AlertThreshold,
			&i.AlertsEnabled,
			&i.StartDate,
			&i.EndDate,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserBudgetsAnalytics = `-- name: GetUserBudgetsAnalytics :one
SELECT
    COUNT(*) as total_budgets,
    COALESCE(SUM(limit_cents), 0)::bigint as total_budget_cents,
    COALESCE(SUM(current_spent_cents), 0)::bigint as total_spent_cents,
    COUNT(*) FILTER (WHERE current_spent_cents > limit_cents) as over_budget_count
FROM budgets
WHERE user_id = $1
`

type GetUserBudgetsAnalyticsRow struct {
	TotalBudgets     int64 `json:"total_budgets"`
	TotalBudgetCents int64 `json:"total_budget_cents"`
	TotalSpentCents  int64 `json:"total_spent_cents"`
	OverBudgetCount  int64 `json:"over_budget_count"`
}

func (q *Queries) GetUserBudgetsAnalytics(ctx context.Context, userID uuid.UUID) (GetUserBudgetsAnalyticsRow, error) {
	row := q.db.QueryRowContext(ctx, getUserBudgetsAnalytics, userID)
	var i GetUserBudgetsAnalyticsRow
	err := row.Scan(
		&i.TotalBudgets,
		&i.TotalBudgetCents,
		&i.TotalSpentCents,
		&i.OverBudgetCount,
	)
	return i, err
}

const incrementBudgetSpent = `-- name: IncrementBudgetSpent :one
UPDATE budgets
SET current_spent_cents = current_spent_cents + $2
WHERE id = $1
RETURNING id, user_id, category, period, limit_cents, current_spent_cents, alert_threshold, alerts_enabled, start_date, end_date, created_at
`

type IncrementBudgetSpentParams struct {
	ID                uuid.UUID     `json:"id"`
	CurrentSpentCents sql.NullInt64 `json:"current_spent_cents"`
}

func (q *Queries) IncrementBudgetSpent(ctx context.Context, arg IncrementBudgetSpentParams) (Budget, error) {
	row := q.db.QueryRowContext(ctx, incrementBudgetSpent, arg.ID, arg.CurrentSpentCents)
	var i Budget
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Category,
		&i.Period,
		&i.LimitCents,
		&i.CurrentSpentCents,
		&i.AlertThreshold,
		&i.AlertsEnabled,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
	)
	return i, err
}

const listUserBudgets = `-- name: ListUserBudgets :many
SELECT id, user_id, category, period, limit_cents, current_spent_cents, alert_threshold, alerts_enabled, start_date, end_date, created_at FROM budgets
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListUserBudgetsParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

func (q *Queries) ListUserBudgets(ctx context.Context, arg ListUserBudgetsParams) ([]Budget, error) {
	rows, err := q.db.QueryContext(ctx, listUserBudgets, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Budget{}
	for rows.Next() {
		var i Budget
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Category,
			&i.Period,
			&i.LimitCents,
			&i.CurrentSpentCents,
			&i.AlertThreshold,
			&i.AlertsEnabled,
			&i.StartDate,
			&i.EndDate,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserBudgetsByCategory = `-- name: ListUserBudgetsByCategory :many
SELECT id, user_id, category, period, limit_cents, current_spent_cents, alert_threshold, alerts_enabled, start_date, end_date, created_at FROM budgets
WHERE user_id = $1 AND category = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListUserBudgetsByCategoryParams struct {
	UserID   uuid.UUID `json:"user_id"`
	Category string    `json:"category"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
}

func (q *Queries) ListUserBudgetsByCategory(ctx context.Context, arg ListUserBudgetsByCategoryParams) ([]Budget, error) {
	rows, err := q.db.QueryContext(ctx, listUserBudgetsByCategory,
		arg.UserID,
		arg.Category,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Budget{}
	for rows.Next() {
		var i Budget
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Category,
			&i.Period,
			&i.LimitCents,
			&i.CurrentSpentCents,
			&i.AlertThreshold,
			&i.AlertsEnabled,
			&i.StartDate,
			&i.EndDate,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserBudgetsByPeriod = `-- name: ListUserBudgetsByPeriod :many
SELECT id, user_id, category, period, limit_cents, current_spent_cents, alert_threshold, alerts_enabled, start_date, end_date, created_at FROM budgets
WHERE user_id = $1 AND period = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListUserBudgetsByPeriodParams struct {
	UserID uuid.UUID `json:"user_id"`
	Period string    `json:"period"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

func (q *Queries) ListUserBudgetsByPeriod(ctx context.Context, arg ListUserBudgetsByPeriodParams) ([]Budget, error) {
	rows, err := q.db.QueryContext(ctx, listUserBudgetsByPeriod,
		arg.UserID,
		arg.Period,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Budget{}
	for rows.Next() {
		var i Budget
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Category,
			&i.Period,
			&i.LimitCents,
			&i.CurrentSpentCents,
			&i.AlertThreshold,
			&i.AlertsEnabled,
			&i.StartDate,
			&i.EndDate,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetBudgetSpent = `-- name: ResetBudgetSpent :exec
UPDATE budgets
SET current_spent_cents = 0
WHERE user_id = $1
`

func (q *Queries) ResetBudgetSpent(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, resetBudgetSpent, userID)
	return err
}

const updateBudget = `-- name: UpdateBudget :one
UPDATE budgets
SET
    limit_cents = $2,
    alert_threshold = $3,
    alerts_enabled = $4
WHERE id = $1
RETURNING id, user_id, category, period, limit_cents, current_spent_cents, alert_threshold, alerts_enabled, start_date, end_date, created_at
`

type UpdateBudgetParams struct {
	ID             uuid.UUID     `json:"id"`
	LimitCents     int64         `json:"limit_cents"`
	AlertThreshold sql.NullInt16 `json:"alert_threshold"`
	AlertsEnabled  sql.NullBool  `json:"alerts_enabled"`
}

func (q *Queries) UpdateBudget(ctx context.Context, arg UpdateBudgetParams) (Budget, error) {
	row := q.db.QueryRowContext(ctx, updateBudget,
		arg.ID,
		arg.LimitCents,
		arg.AlertThreshold,
		arg.AlertsEnabled,
	)
	var i Budget
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Category,
		&i.Period,
		&i.LimitCents,
		&i.CurrentSpentCents,
		&i.AlertThreshold,
		&i.AlertsEnabled,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
	)
	return i, err
}

const updateBudgetSpent = `-- name: UpdateBudgetSpent :one
UPDATE budgets
SET current_spent_cents = $2
WHERE id = $1
RETURNING id, user_id, category, period, limit_cents, current_spent_cents, alert_threshold, alerts_enabled, start_date, end_date, created_at
`

type UpdateBudgetSpentParams struct {
	ID                uuid.UUID     `json:"id"`
	CurrentSpentCents sql.NullInt64 `json:"current_spent_cents"`
}

func (q *Queries) UpdateBudgetSpent(ctx context.Context, arg UpdateBudgetSpentParams) (Budget, error) {
	row := q.db.QueryRowContext(ctx, updateBudgetSpent, arg.ID, arg.CurrentSpentCents)
	var i Budget
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Category,
		&i.Period,
		&i.LimitCents,
		&i.CurrentSpentCents,
		&i.AlertThreshold,
		&i.AlertsEnabled,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
	)
	return i, err
}
