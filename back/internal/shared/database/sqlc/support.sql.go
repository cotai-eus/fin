// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: support.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const countAllTickets = `-- name: CountAllTickets :one
SELECT COUNT(*) FROM support_tickets
`

func (q *Queries) CountAllTickets(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAllTickets)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTicketMessages = `-- name: CountTicketMessages :one
SELECT COUNT(*) FROM ticket_messages
WHERE ticket_id = $1
`

func (q *Queries) CountTicketMessages(ctx context.Context, ticketID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTicketMessages, ticketID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTicketsByStatus = `-- name: CountTicketsByStatus :one
SELECT COUNT(*) FROM support_tickets
WHERE status = $1
`

func (q *Queries) CountTicketsByStatus(ctx context.Context, status string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTicketsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserTickets = `-- name: CountUserTickets :one
SELECT COUNT(*) FROM support_tickets
WHERE user_id = $1
`

func (q *Queries) CountUserTickets(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUserTickets, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserTicketsByStatus = `-- name: CountUserTicketsByStatus :one
SELECT COUNT(*) FROM support_tickets
WHERE user_id = $1
  AND status = $2
`

type CountUserTicketsByStatusParams struct {
	UserID uuid.UUID `json:"user_id"`
	Status string    `json:"status"`
}

func (q *Queries) CountUserTicketsByStatus(ctx context.Context, arg CountUserTicketsByStatusParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUserTicketsByStatus, arg.UserID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTicket = `-- name: CreateTicket :one

INSERT INTO support_tickets (
    user_id,
    ticket_number,
    category,
    priority,
    status,
    subject,
    description
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, user_id, ticket_number, category, priority, status, subject, description, created_at, updated_at
`

type CreateTicketParams struct {
	UserID       uuid.UUID `json:"user_id"`
	TicketNumber string    `json:"ticket_number"`
	Category     string    `json:"category"`
	Priority     string    `json:"priority"`
	Status       string    `json:"status"`
	Subject      string    `json:"subject"`
	Description  string    `json:"description"`
}

// Support Tickets Queries
func (q *Queries) CreateTicket(ctx context.Context, arg CreateTicketParams) (SupportTicket, error) {
	row := q.db.QueryRowContext(ctx, createTicket,
		arg.UserID,
		arg.TicketNumber,
		arg.Category,
		arg.Priority,
		arg.Status,
		arg.Subject,
		arg.Description,
	)
	var i SupportTicket
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TicketNumber,
		&i.Category,
		&i.Priority,
		&i.Status,
		&i.Subject,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTicketMessage = `-- name: CreateTicketMessage :one

INSERT INTO ticket_messages (
    ticket_id,
    user_id,
    message,
    is_staff
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, ticket_id, user_id, message, is_staff, created_at
`

type CreateTicketMessageParams struct {
	TicketID uuid.UUID    `json:"ticket_id"`
	UserID   uuid.UUID    `json:"user_id"`
	Message  string       `json:"message"`
	IsStaff  sql.NullBool `json:"is_staff"`
}

// Ticket Messages Queries
func (q *Queries) CreateTicketMessage(ctx context.Context, arg CreateTicketMessageParams) (TicketMessage, error) {
	row := q.db.QueryRowContext(ctx, createTicketMessage,
		arg.TicketID,
		arg.UserID,
		arg.Message,
		arg.IsStaff,
	)
	var i TicketMessage
	err := row.Scan(
		&i.ID,
		&i.TicketID,
		&i.UserID,
		&i.Message,
		&i.IsStaff,
		&i.CreatedAt,
	)
	return i, err
}

const deleteTicket = `-- name: DeleteTicket :exec
DELETE FROM support_tickets
WHERE id = $1
`

func (q *Queries) DeleteTicket(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteTicket, id)
	return err
}

const deleteTicketMessage = `-- name: DeleteTicketMessage :exec
DELETE FROM ticket_messages
WHERE id = $1
`

func (q *Queries) DeleteTicketMessage(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteTicketMessage, id)
	return err
}

const getLatestTicketMessage = `-- name: GetLatestTicketMessage :one
SELECT id, ticket_id, user_id, message, is_staff, created_at FROM ticket_messages
WHERE ticket_id = $1
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetLatestTicketMessage(ctx context.Context, ticketID uuid.UUID) (TicketMessage, error) {
	row := q.db.QueryRowContext(ctx, getLatestTicketMessage, ticketID)
	var i TicketMessage
	err := row.Scan(
		&i.ID,
		&i.TicketID,
		&i.UserID,
		&i.Message,
		&i.IsStaff,
		&i.CreatedAt,
	)
	return i, err
}

const getTicketByID = `-- name: GetTicketByID :one
SELECT id, user_id, ticket_number, category, priority, status, subject, description, created_at, updated_at FROM support_tickets
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetTicketByID(ctx context.Context, id uuid.UUID) (SupportTicket, error) {
	row := q.db.QueryRowContext(ctx, getTicketByID, id)
	var i SupportTicket
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TicketNumber,
		&i.Category,
		&i.Priority,
		&i.Status,
		&i.Subject,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTicketByNumber = `-- name: GetTicketByNumber :one
SELECT id, user_id, ticket_number, category, priority, status, subject, description, created_at, updated_at FROM support_tickets
WHERE ticket_number = $1
LIMIT 1
`

func (q *Queries) GetTicketByNumber(ctx context.Context, ticketNumber string) (SupportTicket, error) {
	row := q.db.QueryRowContext(ctx, getTicketByNumber, ticketNumber)
	var i SupportTicket
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TicketNumber,
		&i.Category,
		&i.Priority,
		&i.Status,
		&i.Subject,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTicketForUpdate = `-- name: GetTicketForUpdate :one
SELECT id, user_id, ticket_number, category, priority, status, subject, description, created_at, updated_at FROM support_tickets
WHERE id = $1
FOR UPDATE
`

func (q *Queries) GetTicketForUpdate(ctx context.Context, id uuid.UUID) (SupportTicket, error) {
	row := q.db.QueryRowContext(ctx, getTicketForUpdate, id)
	var i SupportTicket
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TicketNumber,
		&i.Category,
		&i.Priority,
		&i.Status,
		&i.Subject,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTicketMessageByID = `-- name: GetTicketMessageByID :one
SELECT id, ticket_id, user_id, message, is_staff, created_at FROM ticket_messages
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetTicketMessageByID(ctx context.Context, id uuid.UUID) (TicketMessage, error) {
	row := q.db.QueryRowContext(ctx, getTicketMessageByID, id)
	var i TicketMessage
	err := row.Scan(
		&i.ID,
		&i.TicketID,
		&i.UserID,
		&i.Message,
		&i.IsStaff,
		&i.CreatedAt,
	)
	return i, err
}

const getTicketStats = `-- name: GetTicketStats :one
SELECT 
    COUNT(*) FILTER (WHERE status = 'open') as open_count,
    COUNT(*) FILTER (WHERE status = 'in_progress') as in_progress_count,
    COUNT(*) FILTER (WHERE status = 'waiting') as waiting_count,
    COUNT(*) FILTER (WHERE status = 'resolved') as resolved_count,
    COUNT(*) FILTER (WHERE status = 'closed') as closed_count,
    COUNT(*) FILTER (WHERE priority = 'urgent') as urgent_count,
    COUNT(*) FILTER (WHERE priority = 'high') as high_count,
    COUNT(*) as total_count
FROM support_tickets
`

type GetTicketStatsRow struct {
	OpenCount       int64 `json:"open_count"`
	InProgressCount int64 `json:"in_progress_count"`
	WaitingCount    int64 `json:"waiting_count"`
	ResolvedCount   int64 `json:"resolved_count"`
	ClosedCount     int64 `json:"closed_count"`
	UrgentCount     int64 `json:"urgent_count"`
	HighCount       int64 `json:"high_count"`
	TotalCount      int64 `json:"total_count"`
}

func (q *Queries) GetTicketStats(ctx context.Context) (GetTicketStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getTicketStats)
	var i GetTicketStatsRow
	err := row.Scan(
		&i.OpenCount,
		&i.InProgressCount,
		&i.WaitingCount,
		&i.ResolvedCount,
		&i.ClosedCount,
		&i.UrgentCount,
		&i.HighCount,
		&i.TotalCount,
	)
	return i, err
}

const listAllTickets = `-- name: ListAllTickets :many

SELECT id, user_id, ticket_number, category, priority, status, subject, description, created_at, updated_at FROM support_tickets
ORDER BY 
    CASE 
        WHEN priority = 'urgent' THEN 1
        WHEN priority = 'high' THEN 2
        WHEN priority = 'medium' THEN 3
        WHEN priority = 'low' THEN 4
    END,
    created_at DESC
LIMIT $1 OFFSET $2
`

type ListAllTicketsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

// Admin/Staff Queries
func (q *Queries) ListAllTickets(ctx context.Context, arg ListAllTicketsParams) ([]SupportTicket, error) {
	rows, err := q.db.QueryContext(ctx, listAllTickets, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SupportTicket{}
	for rows.Next() {
		var i SupportTicket
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TicketNumber,
			&i.Category,
			&i.Priority,
			&i.Status,
			&i.Subject,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTicketMessages = `-- name: ListTicketMessages :many
SELECT id, ticket_id, user_id, message, is_staff, created_at FROM ticket_messages
WHERE ticket_id = $1
ORDER BY created_at ASC
LIMIT $2 OFFSET $3
`

type ListTicketMessagesParams struct {
	TicketID uuid.UUID `json:"ticket_id"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
}

func (q *Queries) ListTicketMessages(ctx context.Context, arg ListTicketMessagesParams) ([]TicketMessage, error) {
	rows, err := q.db.QueryContext(ctx, listTicketMessages, arg.TicketID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TicketMessage{}
	for rows.Next() {
		var i TicketMessage
		if err := rows.Scan(
			&i.ID,
			&i.TicketID,
			&i.UserID,
			&i.Message,
			&i.IsStaff,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTicketsByStatus = `-- name: ListTicketsByStatus :many
SELECT id, user_id, ticket_number, category, priority, status, subject, description, created_at, updated_at FROM support_tickets
WHERE status = $1
ORDER BY 
    CASE 
        WHEN priority = 'urgent' THEN 1
        WHEN priority = 'high' THEN 2
        WHEN priority = 'medium' THEN 3
        WHEN priority = 'low' THEN 4
    END,
    created_at DESC
LIMIT $2 OFFSET $3
`

type ListTicketsByStatusParams struct {
	Status string `json:"status"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListTicketsByStatus(ctx context.Context, arg ListTicketsByStatusParams) ([]SupportTicket, error) {
	rows, err := q.db.QueryContext(ctx, listTicketsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SupportTicket{}
	for rows.Next() {
		var i SupportTicket
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TicketNumber,
			&i.Category,
			&i.Priority,
			&i.Status,
			&i.Subject,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserTickets = `-- name: ListUserTickets :many
SELECT id, user_id, ticket_number, category, priority, status, subject, description, created_at, updated_at FROM support_tickets
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListUserTicketsParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

func (q *Queries) ListUserTickets(ctx context.Context, arg ListUserTicketsParams) ([]SupportTicket, error) {
	rows, err := q.db.QueryContext(ctx, listUserTickets, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SupportTicket{}
	for rows.Next() {
		var i SupportTicket
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TicketNumber,
			&i.Category,
			&i.Priority,
			&i.Status,
			&i.Subject,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserTicketsByStatus = `-- name: ListUserTicketsByStatus :many
SELECT id, user_id, ticket_number, category, priority, status, subject, description, created_at, updated_at FROM support_tickets
WHERE user_id = $1
  AND status = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListUserTicketsByStatusParams struct {
	UserID uuid.UUID `json:"user_id"`
	Status string    `json:"status"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

func (q *Queries) ListUserTicketsByStatus(ctx context.Context, arg ListUserTicketsByStatusParams) ([]SupportTicket, error) {
	rows, err := q.db.QueryContext(ctx, listUserTicketsByStatus,
		arg.UserID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SupportTicket{}
	for rows.Next() {
		var i SupportTicket
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TicketNumber,
			&i.Category,
			&i.Priority,
			&i.Status,
			&i.Subject,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTicket = `-- name: UpdateTicket :one
UPDATE support_tickets
SET status = $2,
    priority = $3,
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, ticket_number, category, priority, status, subject, description, created_at, updated_at
`

type UpdateTicketParams struct {
	ID       uuid.UUID `json:"id"`
	Status   string    `json:"status"`
	Priority string    `json:"priority"`
}

func (q *Queries) UpdateTicket(ctx context.Context, arg UpdateTicketParams) (SupportTicket, error) {
	row := q.db.QueryRowContext(ctx, updateTicket, arg.ID, arg.Status, arg.Priority)
	var i SupportTicket
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TicketNumber,
		&i.Category,
		&i.Priority,
		&i.Status,
		&i.Subject,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTicketStatus = `-- name: UpdateTicketStatus :one
UPDATE support_tickets
SET status = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, ticket_number, category, priority, status, subject, description, created_at, updated_at
`

type UpdateTicketStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status string    `json:"status"`
}

func (q *Queries) UpdateTicketStatus(ctx context.Context, arg UpdateTicketStatusParams) (SupportTicket, error) {
	row := q.db.QueryRowContext(ctx, updateTicketStatus, arg.ID, arg.Status)
	var i SupportTicket
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TicketNumber,
		&i.Category,
		&i.Priority,
		&i.Status,
		&i.Subject,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
